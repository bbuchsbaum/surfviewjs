<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GIFTI Debug Test</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background: #f0f0f0;
    }
    #viewer-container {
      width: 100vw;
      height: 100vh;
    }
    #debug {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px;
      border-radius: 5px;
      font-family: monospace;
      font-size: 12px;
      max-width: 400px;
      max-height: 80vh;
      overflow-y: auto;
    }
    .debug-line {
      margin: 2px 0;
    }
    .error {
      color: #ff5555;
    }
    .success {
      color: #55ff55;
    }
    .info {
      color: #5555ff;
    }
  </style>
</head>
<body>
  <div id="viewer-container"></div>
  <div id="debug"></div>
  
  <script type="module">
    import * as THREE from 'three';
    import { 
      NeuroSurfaceViewer, 
      MultiLayerNeuroSurface,
      DataLayer,
      loadSurface,
      parseGIfTISurface
    } from './src/index.js';
    
    const debugEl = document.getElementById('debug');
    
    function log(message, type = '') {
      const line = document.createElement('div');
      line.className = `debug-line ${type}`;
      line.textContent = message;
      debugEl.appendChild(line);
      console.log(message);
    }
    
    async function debugGifti() {
      let viewer = null;
      let lastAnnotationId = null;
      let handleClick = null;
      try {
        log('Starting GIFTI debug test...');
        
        // Load and parse GIFTI manually first
        log('Fetching GIFTI file...');
        const response = await fetch('./tests/data/ascii.surf.gii');
        const text = await response.text();
        log(`GIFTI file size: ${text.length} bytes`, 'info');
        
        // Parse the GIFTI
        log('Parsing GIFTI...');
        const parsed = parseGIfTISurface(text);
        log(`Parsed vertices: ${parsed.vertices.length} values (${parsed.vertices.length/3} vertices)`, 'success');
        log(`Parsed faces: ${parsed.faces.length} values (${parsed.faces.length/3} triangles)`, 'success');
        
        // Check some vertex values
        log('First 3 vertices:', 'info');
        for (let i = 0; i < 3; i++) {
          const x = parsed.vertices[i * 3];
          const y = parsed.vertices[i * 3 + 1];
          const z = parsed.vertices[i * 3 + 2];
          log(`  Vertex ${i}: (${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)})`);
        }
        
        // Check bounds
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        let minZ = Infinity, maxZ = -Infinity;
        
        for (let i = 0; i < parsed.vertices.length; i += 3) {
          minX = Math.min(minX, parsed.vertices[i]);
          maxX = Math.max(maxX, parsed.vertices[i]);
          minY = Math.min(minY, parsed.vertices[i + 1]);
          maxY = Math.max(maxY, parsed.vertices[i + 1]);
          minZ = Math.min(minZ, parsed.vertices[i + 2]);
          maxZ = Math.max(maxZ, parsed.vertices[i + 2]);
        }
        
        log(`Bounds X: [${minX.toFixed(2)}, ${maxX.toFixed(2)}]`, 'info');
        log(`Bounds Y: [${minY.toFixed(2)}, ${maxY.toFixed(2)}]`, 'info');
        log(`Bounds Z: [${minZ.toFixed(2)}, ${maxZ.toFixed(2)}]`, 'info');
        
        // Load using the loader
        log('\nLoading surface with loader...');
        const geometry = await loadSurface('./tests/data/ascii.surf.gii', 'gifti', 'left');
        log(`Loaded geometry - vertices: ${geometry.vertices.length}, faces: ${geometry.faces.length}`, 'success');
        
        // Create viewer
        log('\nInitializing viewer...');
        const container = document.getElementById('viewer-container');
        viewer = new NeuroSurfaceViewer(
          container,
          window.innerWidth,
          window.innerHeight,
          {
            showControls: true,
            ambientLightColor: 0x404040,
            directionalLightIntensity: 0.8
          }
        );
        
        // Start render loop
        viewer.startRenderLoop();
        log('Render loop started', 'success');
        
        // Create surface
        log('\nCreating MultiLayerNeuroSurface...');
        const surface = new MultiLayerNeuroSurface(geometry, {
          baseColor: 0xcccccc,
          metalness: 0.3,
          roughness: 0.7
        });
        log('Surface created', 'success');
        
        // Check mesh
        if (surface.mesh) {
          log(`Mesh exists: ${surface.mesh.type}`, 'success');
          
          // Check geometry
          const meshGeom = surface.mesh.geometry;
          if (meshGeom) {
            const posAttr = meshGeom.getAttribute('position');
            const indexAttr = meshGeom.index;
            log(`Mesh geometry - positions: ${posAttr ? posAttr.count : 0}, indexed: ${indexAttr ? 'yes' : 'no'}`, 'info');
            
            // Compute bounding box
            meshGeom.computeBoundingBox();
            const box = meshGeom.boundingBox;
            if (box) {
              log(`Mesh bounds: (${box.min.x.toFixed(2)}, ${box.min.y.toFixed(2)}, ${box.min.z.toFixed(2)}) to (${box.max.x.toFixed(2)}, ${box.max.y.toFixed(2)}, ${box.max.z.toFixed(2)})`, 'info');
            }
          }
        } else {
          log('ERROR: No mesh created!', 'error');
        }
        
        // Add to viewer
        log('\nAdding surface to viewer...');
        viewer.addSurface(surface, 'brain');
        log('Surface added', 'success');
        
        // Check scene
        log(`Scene children: ${viewer.scene.children.length}`, 'info');
        viewer.scene.traverse((child) => {
          if (child instanceof THREE.Mesh) {
            log(`  Found mesh: ${child.type}, visible: ${child.visible}`, 'info');
          }
        });
        
        // Center camera
        log('\nCentering camera...');
        viewer.centerCamera();
        log(`Camera position: (${viewer.camera.position.x.toFixed(2)}, ${viewer.camera.position.y.toFixed(2)}, ${viewer.camera.position.z.toFixed(2)})`, 'info');
        
        // Force render
        viewer.requestRender();

        // Simple click-to-annotate demo using new picking + annotation APIs
        handleClick = (event) => {
          if (!viewer) return;
          const hit = viewer.pick({ x: event.clientX, y: event.clientY, opacityThreshold: 0.05 });
          if (!hit.surfaceId || hit.vertexIndex === null) {
            log('Click: no hit');
            return;
          }

          // Replace previous annotation for clarity
          if (lastAnnotationId) {
            viewer.removeAnnotation(lastAnnotationId);
          }

          lastAnnotationId = viewer.addAnnotation(hit.surfaceId, hit.vertexIndex, { note: 'click' }, { active: true });
          log(`Click: surface=${hit.surfaceId} vertex=${hit.vertexIndex}`, 'info');
        };

        viewer.renderer.domElement.addEventListener('click', handleClick);
        
        log('\nDebug complete!', 'success');
        
      } catch (error) {
        log(`ERROR: ${error.message}`, 'error');
        console.error(error);
      } finally {
        // Clean up annotation listener when page unloads
        window.addEventListener('beforeunload', () => {
          if (viewer && handleClick) {
            viewer.renderer.domElement.removeEventListener('click', handleClick);
          }
        });
      }
    }
    
    // Run debug
    debugGifti();
  </script>
</body>
</html>
