<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetrahedron GIFTI Test</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background-color: #1a1a1a;
      color: white;
    }
    #viewer-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    .info h2 {
      margin-top: 0;
      color: #4CAF50;
    }
    .info p {
      margin: 5px 0;
      font-size: 14px;
    }
    .status {
      color: #FFC107;
    }
    .success {
      color: #4CAF50;
    }
    .error {
      color: #f44336;
    }
  </style>
</head>
<body>
  <div id="viewer-container"></div>
  <div class="info">
    <h2>Tetrahedron GIFTI Test</h2>
    <p>File: tests/data/tetrahedron.gii</p>
    <p class="status" id="status">Loading...</p>
    <p id="vertices"></p>
    <p id="faces"></p>
    <p id="bounds"></p>
  </div>
  
  <script type="module">
    import { 
      NeuroSurfaceViewer, 
      SurfaceGeometry, 
      ColorMappedNeuroSurface, 
      VertexColoredNeuroSurface, 
      THREE, 
      setDebug,
      loadSurface 
    } from './src/index.js';
    
    // Enable debug logging
    setDebug(true);
    
    const statusEl = document.getElementById('status');
    const verticesEl = document.getElementById('vertices');
    const facesEl = document.getElementById('faces');
    const boundsEl = document.getElementById('bounds');
    
    // Create viewer
    const container = document.getElementById('viewer-container');
    const viewer = new NeuroSurfaceViewer(
      container,
      window.innerWidth,
      window.innerHeight,
      {
        showControls: true,
        backgroundColor: 0x1a1a1a,
        ambientLightColor: 0x808080,
        directionalLightIntensity: 1.0
      }
    );
    
    // Start render loop
    viewer.startRenderLoop();
    
    // Load tetrahedron
    async function loadTetrahedron() {
      try {
        statusEl.textContent = 'Loading tetrahedron.gii...';
        statusEl.className = 'status';
        
        // Load the GIFTI surface with auto-scaling
        const surfaceGeom = await loadSurface(
          './tests/data/tetrahedron.gii',
          'gifti',
          'unknown',
          30000,  // timeout
          true,   // autoScale
          50      // targetSize
        );
        
        // Display statistics
        const vertexCount = surfaceGeom.vertices.length / 3;
        const faceCount = surfaceGeom.faces.length / 3;
        
        verticesEl.textContent = `Vertices: ${vertexCount}`;
        facesEl.textContent = `Faces: ${faceCount}`;
        
        // Calculate bounds
        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
        
        for (let i = 0; i < surfaceGeom.vertices.length; i += 3) {
          minX = Math.min(minX, surfaceGeom.vertices[i]);
          maxX = Math.max(maxX, surfaceGeom.vertices[i]);
          minY = Math.min(minY, surfaceGeom.vertices[i + 1]);
          maxY = Math.max(maxY, surfaceGeom.vertices[i + 1]);
          minZ = Math.min(minZ, surfaceGeom.vertices[i + 2]);
          maxZ = Math.max(maxZ, surfaceGeom.vertices[i + 2]);
        }
        
        boundsEl.textContent = `Bounds: X[${minX.toFixed(3)}, ${maxX.toFixed(3)}] Y[${minY.toFixed(3)}, ${maxY.toFixed(3)}] Z[${minZ.toFixed(3)}, ${maxZ.toFixed(3)}]`;
        
        // Log vertices and faces for debugging
        console.log('Vertices:');
        for (let i = 0; i < vertexCount; i++) {
          const x = surfaceGeom.vertices[i * 3];
          const y = surfaceGeom.vertices[i * 3 + 1];
          const z = surfaceGeom.vertices[i * 3 + 2];
          console.log(`  Vertex ${i}: (${x.toFixed(3)}, ${y.toFixed(3)}, ${z.toFixed(3)})`);
        }
        
        console.log('Faces:');
        for (let i = 0; i < faceCount; i++) {
          const v0 = surfaceGeom.faces[i * 3];
          const v1 = surfaceGeom.faces[i * 3 + 1];
          const v2 = surfaceGeom.faces[i * 3 + 2];
          console.log(`  Face ${i}: [${v0}, ${v1}, ${v2}]`);
        }
        
        // Create data for visualization (one value per vertex)
        const data = new Float32Array(vertexCount);
        for (let i = 0; i < vertexCount; i++) {
          // Color based on vertex height (z-coordinate)
          data[i] = surfaceGeom.vertices[i * 3 + 2] * 100; // Scale up for better color range
        }
        
        // Create color mapped surface (same as main page)
        const surface = new ColorMappedNeuroSurface(
          surfaceGeom,
          Array.from({length: vertexCount}, (_, i) => i),
          data,
          'viridis',
          {
            alpha: 1.0,
            flatShading: true // Use flat shading to see faces clearly
          }
        );
        
        viewer.addSurface(surface, 'tetrahedron');
        viewer.centerCamera();
        
        statusEl.textContent = 'Successfully loaded!';
        statusEl.className = 'success';
        
        console.log('Tetrahedron loaded successfully!');
        console.log('Surface geometry:', surfaceGeom);
        
      } catch (error) {
        console.error('Error loading tetrahedron:', error);
        statusEl.textContent = `Error: ${error.message}`;
        statusEl.className = 'error';
      }
    }
    
    // Load on page load
    loadTetrahedron();
    
    // Handle window resize
    window.addEventListener('resize', () => {
      viewer.resize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>