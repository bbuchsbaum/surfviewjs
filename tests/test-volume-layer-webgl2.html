<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VolumeProjectionLayer WebGL2 Test</title>
  <style>
    :root {
      color-scheme: dark;
    }
    body {
      margin: 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace;
      background: #0b1020;
      color: #e6e6e6;
    }
    header {
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.03);
    }
    h1 {
      margin: 0;
      font-size: 14px;
      font-weight: 600;
    }
    .sub {
      margin-top: 6px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.75);
      line-height: 1.35;
    }
    main {
      padding: 12px 14px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 10px;
      padding: 12px;
    }
    .row {
      display: flex;
      gap: 10px;
      align-items: baseline;
      flex-wrap: wrap;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
    }
    .pass { color: #8bf59a; }
    .fail { color: #ffb4b4; }
    pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 12px;
      line-height: 1.35;
      color: rgba(255, 255, 255, 0.85);
    }
  </style>
</head>
<body>
  <header>
    <h1>VolumeProjectionLayer WebGL2 Runtime Test</h1>
    <div class="sub">
      Renders a tiny point grid with <code>GPULayerCompositor</code> + <code>VolumeProjectionLayer</code>, reads pixels, and compares against CPU projection.
    </div>
  </header>
  <main>
    <div class="card">
      <div class="row">
        <div class="pill" id="status-pill">Running…</div>
        <div class="pill" id="support-pill">Checking WebGL2…</div>
      </div>
    </div>
    <div class="card">
      <pre id="log"></pre>
    </div>
  </main>

  <script type="module">
    import { THREE, GPULayerCompositor, VolumeProjectionLayer, ColorMap } from '../src/index.js';

    const logEl = document.getElementById('log');
    const statusPill = document.getElementById('status-pill');
    const supportPill = document.getElementById('support-pill');

    function appendLog(line) {
      logEl.textContent += `${line}\n`;
    }

    function setPill(el, text, className) {
      el.textContent = text;
      el.className = `pill ${className || ''}`.trim();
    }

    function clamp01(v) {
      return Math.min(1, Math.max(0, v));
    }

    function maxAbsDiff(a, b) {
      let max = 0;
      for (let i = 0; i < a.length; i++) {
        const d = Math.abs(a[i] - b[i]);
        if (d > max) max = d;
      }
      return max;
    }

    function computeExpectedRGBAFromVoxels({
      voxels,
      volumeData,
      dims,
      colormapName,
      range,
      threshold,
      fillValue
    }) {
      const cmap = ColorMap.fromPreset(colormapName);
      cmap.setRange(range);
      cmap.setThreshold(threshold);

      const [nx, ny, nz] = dims;
      const rgba = new Float32Array(voxels.length * 4);
      rgba.fill(0);

      for (let v = 0; v < voxels.length; v++) {
        const [i, j, k] = voxels[v];
        const offset = v * 4;
        if (i < 0 || j < 0 || k < 0 || i >= nx || j >= ny || k >= nz) {
          continue;
        }
        const idx = i + nx * j + nx * ny * k;
        const value = volumeData[idx];
        if (!isFinite(value)) continue;
        if (Math.abs(value - fillValue) < 1e-6) continue;

        const c = cmap.getColor(value);
        rgba[offset] = c[0] ?? 0;
        rgba[offset + 1] = c[1] ?? 0;
        rgba[offset + 2] = c[2] ?? 0;
        rgba[offset + 3] = c[3] ?? 1;
      }

      return rgba;
    }

    function makeVolumeData(dims) {
      const [nx, ny, nz] = dims;
      const data = new Float32Array(nx * ny * nz);
      let idx = 0;
      for (let k = 0; k < nz; k++) {
        for (let j = 0; j < ny; j++) {
          for (let i = 0; i < nx; i++) {
            data[idx++] = i + 10 * j + 100 * k;
          }
        }
      }
      return data;
    }

    function setupRenderer() {
      const canvas = document.createElement('canvas');
      canvas.width = 16;
      canvas.height = 16;
      canvas.style.display = 'none';
      document.body.appendChild(canvas);

      const context = canvas.getContext('webgl2', { antialias: false, depth: false, stencil: false });
      if (!context) {
        return { renderer: null, gl: null };
      }

      const renderer = new THREE.WebGLRenderer({
        canvas,
        context,
        antialias: false,
        alpha: false,
        depth: false,
        stencil: false,
        preserveDrawingBuffer: false
      });
      renderer.setPixelRatio(1);
      renderer.toneMapping = THREE.NoToneMapping;
      renderer.toneMappingExposure = 1.0;
      renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
      renderer.autoClear = true;

      return { renderer, gl: context };
    }

    function buildPointGrid({ width, height, worldPositions, meshTranslation }) {
      const vertexCount = width * height;
      const positions = new Float32Array(vertexCount * 3);
      const normals = new Float32Array(vertexCount * 3);
      const vertexIndex = new Float32Array(vertexCount);

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const v = x + width * y;
          const offset = v * 3;
          const wp = worldPositions[v];
          positions[offset] = wp[0] - meshTranslation[0];
          positions[offset + 1] = wp[1] - meshTranslation[1];
          positions[offset + 2] = wp[2] - meshTranslation[2];

          normals[offset] = 0;
          normals[offset + 1] = 0;
          normals[offset + 2] = 1;
          vertexIndex[v] = v;
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
      geometry.setAttribute('vertexIndex', new THREE.BufferAttribute(vertexIndex, 1));
      geometry.computeBoundingSphere();

      const points = new THREE.Points(geometry);
      points.frustumCulled = false;
      points.position.set(meshTranslation[0], meshTranslation[1], meshTranslation[2]);
      points.updateMatrixWorld(true);

      return { points, vertices: positions, vertexCount };
    }

    function makeOrthoCameraForGrid({ width, height, worldPositions }) {
      let minX = Infinity;
      let maxX = -Infinity;
      let minY = Infinity;
      let maxY = -Infinity;
      for (const [x, y] of worldPositions) {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }

      // Infer step size from the first row/column when possible.
      const stepX = width > 1 ? Math.abs(worldPositions[1][0] - worldPositions[0][0]) : 1;
      const stepY = height > 1 ? Math.abs(worldPositions[width][1] - worldPositions[0][1]) : 1;

      const left = minX - stepX * 0.5;
      const right = minX + stepX * width - stepX * 0.5;
      const bottom = minY - stepY * 0.5;
      const top = minY + stepY * height - stepY * 0.5;

      const camera = new THREE.OrthographicCamera(left, right, top, bottom, 0, 10);
      camera.position.set(0, 0, 1);
      camera.lookAt(0, 0, 0);
      camera.updateMatrixWorld(true);
      camera.updateProjectionMatrix();

      return camera;
    }

    function readPixels(renderer, scene, camera, width, height) {
      const target = new THREE.WebGLRenderTarget(width, height, {
        depthBuffer: false,
        stencilBuffer: false
      });
      target.texture.colorSpace = THREE.LinearSRGBColorSpace;

      renderer.setRenderTarget(target);
      renderer.clear();
      renderer.render(scene, camera);

      const pixels = new Uint8Array(width * height * 4);
      renderer.readRenderTargetPixels(target, 0, 0, width, height, pixels);

      renderer.setRenderTarget(null);
      target.dispose();
      return pixels;
    }

    function comparePixels({ pixels, expectedRGB, tolerance }) {
      const pixelRGB = new Float32Array(expectedRGB.length);
      for (let i = 0; i < pixels.length; i += 4) {
        const j = (i / 4) * 3;
        pixelRGB[j] = pixels[i] / 255;
        pixelRGB[j + 1] = pixels[i + 1] / 255;
        pixelRGB[j + 2] = pixels[i + 2] / 255;
      }

      const maxDiff = maxAbsDiff(pixelRGB, expectedRGB);
      return { ok: maxDiff <= tolerance, maxDiff };
    }

    async function runCase({ name, width, height, dims, volumeToWorld, layerConfig, meshTranslation, fillVoxel }) {
      appendLog(`\n[case] ${name}`);

      const volumeData = makeVolumeData(dims);
      if (fillVoxel) {
        const [i, j, k, fillValue] = fillVoxel;
        const idx = i + dims[0] * j + dims[0] * dims[1] * k;
        volumeData[idx] = fillValue;
      }

      const voxels = [];
      const worldPositions = [];
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const [i, j, k] = layerConfig.voxelIndexForPixel(x, y);
          voxels.push([i, j, k]);

          const wp = new THREE.Vector3(i, j, k).applyMatrix4(volumeToWorld);
          worldPositions.push([wp.x, wp.y, wp.z]);
        }
      }

      const expectedRGBA = computeExpectedRGBAFromVoxels({
        voxels,
        volumeData,
        dims,
        colormapName: layerConfig.colormap,
        range: layerConfig.range,
        threshold: layerConfig.threshold,
        fillValue: layerConfig.fillValue
      });

      const { points, vertices, vertexCount } = buildPointGrid({
        width,
        height,
        worldPositions,
        meshTranslation
      });

      const layer = new VolumeProjectionLayer('vol', volumeData, dims, {
        colormap: layerConfig.colormap,
        range: layerConfig.range,
        threshold: layerConfig.threshold,
        opacity: 1.0,
        blendMode: 'normal',
        fillValue: layerConfig.fillValue,
        useHalfFloat: layerConfig.useHalfFloat,
        voxelSize: layerConfig.voxelSize,
        volumeOrigin: layerConfig.volumeOrigin,
        affineMatrix: layerConfig.affineMatrix
      });

      layer.attach({ geometry: { vertices }, mesh: points });

      const expectedWorldToIJK = volumeToWorld.clone().invert();
      const actualWorldToIJK = layer.getWorldToIJK();
      const expectedElements = expectedWorldToIJK.elements;
      const actualElements = actualWorldToIJK.elements;
      let matrixDiff = 0;
      for (let i = 0; i < 16; i++) {
        const d = Math.abs(expectedElements[i] - actualElements[i]);
        if (d > matrixDiff) matrixDiff = d;
      }
      appendLog(`worldToIJK maxAbsDiff vs expected inverse: ${matrixDiff}`);

      const volumeTexture = layer.getVolumeTexture().texture;
      const expectedType = layerConfig.useHalfFloat ? THREE.HalfFloatType : THREE.FloatType;
      const typeOk = volumeTexture.type === expectedType;
      const dataOk = layerConfig.useHalfFloat
        ? (volumeTexture.image.data instanceof Uint16Array)
        : (volumeTexture.image.data instanceof Float32Array);
      appendLog(`volume texture type: ${typeOk ? 'OK' : `FAIL (got ${volumeTexture.type})`}`);
      appendLog(`volume texture buffer: ${dataOk ? 'OK' : 'FAIL'}`);

      volumeTexture.minFilter = THREE.NearestFilter;
      volumeTexture.magFilter = THREE.NearestFilter;
      volumeTexture.needsUpdate = true;

      const cpuRGBA = layer.getRGBAData(vertexCount);
      const cpuDiff = maxAbsDiff(cpuRGBA, expectedRGBA);
      appendLog(`cpu maxAbsDiff vs expected: ${cpuDiff}`);

      const baseColor = new THREE.Color(0x243040);
      const expectedRGB = new Float32Array(vertexCount * 3);
      for (let v = 0; v < vertexCount; v++) {
        const o = v * 4;
        const rgb = v * 3;
        const a = cpuRGBA[o + 3];
        if (a > 0) {
          expectedRGB[rgb] = clamp01(cpuRGBA[o]);
          expectedRGB[rgb + 1] = clamp01(cpuRGBA[o + 1]);
          expectedRGB[rgb + 2] = clamp01(cpuRGBA[o + 2]);
        } else {
          expectedRGB[rgb] = baseColor.r;
          expectedRGB[rgb + 1] = baseColor.g;
          expectedRGB[rgb + 2] = baseColor.b;
        }
      }

      const compositor = new GPULayerCompositor(vertexCount, 8);
      compositor.updateLayers([layer]);

      const material = compositor.getMaterial();
      if (!material) throw new Error('GPULayerCompositor did not create a material');
      material.uniforms.baseColor.value.copy(baseColor);
      material.uniforms.ambientLight.value.setRGB(1, 1, 1);
      material.uniforms.directionalLight.value.setRGB(0, 0, 0);
      material.transparent = false;
      material.depthTest = false;
      material.depthWrite = false;
      material.blending = THREE.NoBlending;
      material.needsUpdate = true;

      points.material = material;

      const scene = new THREE.Scene();
      scene.add(points);

      const camera = makeOrthoCameraForGrid({ width, height, worldPositions });

      const pixels = readPixels(layerConfig.renderer, scene, camera, width, height);
      const tolerance = layerConfig.pixelTolerance ?? 0.06;
      const { ok: gpuOk, maxDiff: gpuDiff } = comparePixels({ pixels, expectedRGB, tolerance });
      appendLog(`gpu maxAbsDiff vs cpu: ${gpuDiff} (tolerance ${tolerance})`);

      const ok = matrixDiff <= 1e-6 && typeOk && dataOk && cpuDiff <= 1e-5 && gpuOk;
      appendLog(ok ? 'PASS' : 'FAIL');

      compositor.dispose();
      layer.dispose();
      points.geometry.dispose();

      return {
        name,
        ok,
        cpuDiff,
        gpuDiff,
        dims,
        halfFloat: layerConfig.useHalfFloat
      };
    }

    async function run() {
      const results = {
        skipped: false,
        reason: '',
        pass: false,
        cases: []
      };

      const { renderer, gl } = setupRenderer();
      if (!renderer || !gl) {
        results.skipped = true;
        results.reason = 'WebGL2 not available';
        setPill(supportPill, 'WebGL2 unavailable', 'fail');
        setPill(statusPill, 'SKIPPED', 'fail');
        window.__VOLUME_LAYER_WEBGL2_TEST__ = results;
        return;
      }

      setPill(supportPill, 'WebGL2 OK', 'pass');

      const dims = [4, 4, 4];
      const fillValue = -1;

      const volumeToWorld1 = new THREE.Matrix4().set(
        2, 0, 0, 10,
        0, 3, 0, 20,
        0, 0, 4, -5,
        0, 0, 0, 1
      );

      const volumeToWorld2 = new THREE.Matrix4().set(
        0, 1, 0, 30,
        1, 0, 0, -40,
        0, 0, 1, 5,
        0, 0, 0, 1
      );

      const volumeToWorld3 = new THREE.Matrix4().identity();

      const common = {
        renderer,
        colormap: 'viridis',
        range: [0, 333],
        threshold: [100, 200],
        fillValue,
        voxelIndexForPixel: (x, y) => [x, y, (x + y) % dims[2]]
      };

      results.cases.push(await runCase({
        name: 'voxelSize/origin + mesh translation',
        width: 4,
        height: 4,
        dims,
        volumeToWorld: volumeToWorld1,
        meshTranslation: [5, -7, 3],
        fillVoxel: [2, 1, 0, fillValue],
        layerConfig: {
          ...common,
          voxelSize: [2, 3, 4],
          volumeOrigin: [10, 20, -5],
          affineMatrix: undefined,
          useHalfFloat: false,
          pixelTolerance: 0.06
        }
      }));

      results.cases.push(await runCase({
        name: 'affineMatrix axis-swap',
        width: 4,
        height: 4,
        dims,
        volumeToWorld: volumeToWorld2,
        meshTranslation: [-3, 2, 0],
        fillVoxel: [1, 2, 0, fillValue],
        layerConfig: {
          ...common,
          threshold: [0, 0],
          voxelIndexForPixel: (x, y) => [y, x, (x + y) % dims[2]],
          affineMatrix: volumeToWorld2,
          voxelSize: undefined,
          volumeOrigin: undefined,
          useHalfFloat: false,
          pixelTolerance: 0.06
        }
      }));

      results.cases.push(await runCase({
        name: 'half-float volume texture',
        width: 4,
        height: 4,
        dims,
        volumeToWorld: volumeToWorld3,
        meshTranslation: [0, 0, 0],
        fillVoxel: [0, 0, 0, fillValue],
        layerConfig: {
          ...common,
          threshold: [0, 0],
          voxelIndexForPixel: (x, y) => [x, y, (x + y) % dims[2]],
          affineMatrix: volumeToWorld3,
          voxelSize: undefined,
          volumeOrigin: undefined,
          useHalfFloat: true,
          pixelTolerance: 0.06
        }
      }));

      results.pass = results.cases.every(c => c.ok);
      setPill(statusPill, results.pass ? 'PASS' : 'FAIL', results.pass ? 'pass' : 'fail');

      renderer.dispose();
      window.__VOLUME_LAYER_WEBGL2_TEST__ = results;
    }

    run().catch((err) => {
      appendLog(`ERROR: ${err?.stack || err}`);
      setPill(statusPill, 'FAIL', 'fail');
      window.__VOLUME_LAYER_WEBGL2_TEST__ = { skipped: false, pass: false, cases: [], error: String(err?.stack || err) };
    });
  </script>
</body>
</html>
