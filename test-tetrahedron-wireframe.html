<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetrahedron GIFTI Test - Wireframe</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background-color: #1a1a1a;
      color: white;
    }
    #viewer-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    .info h2 {
      margin-top: 0;
      color: #4CAF50;
    }
    .controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 5px;
    }
    button {
      padding: 8px 15px;
      margin: 5px;
      cursor: pointer;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 3px;
    }
    button:hover {
      background: #45a049;
    }
  </style>
</head>
<body>
  <div id="viewer-container"></div>
  <div class="info">
    <h2>Tetrahedron Wireframe Test</h2>
    <p>File: tests/data/tetrahedron.gii</p>
    <p id="status">Loading...</p>
  </div>
  <div class="controls">
    <button id="toggle-wireframe">Toggle Wireframe</button>
    <button id="toggle-mesh">Toggle Mesh</button>
    <button id="toggle-vertices">Toggle Vertices</button>
  </div>
  
  <script type="module">
    import * as THREE from 'three';
    
    // Create scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a1a);
    
    // Create camera
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(100, 100, 100);
    camera.lookAt(0, 0, 0);
    
    // Create renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('viewer-container').appendChild(renderer.domElement);
    
    // Add lights
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(100, 100, 50);
    scene.add(directionalLight);
    
    // Add orbit controls
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    const controls = new OrbitControls(camera, renderer.domElement);
    
    // Load and parse GIFTI manually
    async function loadTetrahedron() {
      try {
        const response = await fetch('./tests/data/tetrahedron.gii');
        const text = await response.text();
        
        // Parse vertices
        const vertexMatch = text.match(/<Data>([^<]+)<\/Data>/g)[0];
        const vertexData = vertexMatch.replace(/<\/?Data>/g, '').trim().split(/\s+/).map(Number);
        
        // Parse faces
        const faceMatch = text.match(/<Data>([^<]+)<\/Data>/g)[1];
        const faceData = faceMatch.replace(/<\/?Data>/g, '').trim().split(/\s+/).map(Number);
        
        console.log('Vertices:', vertexData);
        console.log('Faces:', faceData);
        
        // Scale up vertices
        const scaleFactor = 50;
        const scaledVertices = vertexData.map(v => v * scaleFactor);
        
        // Create geometry
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(scaledVertices, 3));
        geometry.setIndex(faceData);
        geometry.computeVertexNormals();
        
        // Create mesh with solid material
        const material = new THREE.MeshPhongMaterial({
          color: 0x00ff00,
          side: THREE.DoubleSide,
          flatShading: true,
          transparent: true,
          opacity: 0.8
        });
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);
        
        // Create wireframe
        const wireframeGeometry = new THREE.WireframeGeometry(geometry);
        const wireframeMaterial = new THREE.LineBasicMaterial({ 
          color: 0xffffff,
          linewidth: 2
        });
        const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
        scene.add(wireframe);
        
        // Create vertex points
        const pointsGeometry = new THREE.BufferGeometry();
        pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(scaledVertices, 3));
        const pointsMaterial = new THREE.PointsMaterial({
          color: 0xff0000,
          size: 5,
          sizeAttenuation: false
        });
        const points = new THREE.Points(pointsGeometry, pointsMaterial);
        scene.add(points);
        
        // Add coordinate axes
        const axesHelper = new THREE.AxesHelper(100);
        scene.add(axesHelper);
        
        // Toggle controls
        document.getElementById('toggle-wireframe').addEventListener('click', () => {
          wireframe.visible = !wireframe.visible;
        });
        
        document.getElementById('toggle-mesh').addEventListener('click', () => {
          mesh.visible = !mesh.visible;
        });
        
        document.getElementById('toggle-vertices').addEventListener('click', () => {
          points.visible = !points.visible;
        });
        
        document.getElementById('status').textContent = 'Loaded successfully!';
        
      } catch (error) {
        console.error('Error loading tetrahedron:', error);
        document.getElementById('status').textContent = 'Error: ' + error.message;
      }
    }
    
    loadTetrahedron();
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
    
    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>